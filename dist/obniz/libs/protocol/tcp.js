"use strict";
const isNode = typeof window === 'undefined';
const semver = require('semver');
class Tcp {
    constructor(Obniz, id) {
        this.Obniz = Obniz;
        this.id = id;
        this._reset();
    }
    _reset() {
        this.connectObservers = [];
        this.readObservers = [];
        this.used = false;
    }
    _addConnectObserver(callback) {
        if (callback) {
            this.connectObservers.push(callback);
        }
    }
    _addReadObserver(callback) {
        if (callback) {
            this.readObservers.push(callback);
        }
    }
    connectWait(port, domain) {
        if (semver.lt(this.Obniz.firmware_ver, '2.1.0')) {
            throw new Error(`Please update obniz firmware >= 2.1.0`);
        }
        // TODO
        // if (this.used) {
        //   throw new Error(`tcp${this.id} is in used`);
        // }
        if (port < 0 || port > 65535) {
            throw new Error(`tcp${this.id} is invalid port`);
        }
        if (domain.length > 30) {
            throw new Error(`tcp${this.id} is domain length over`);
        }
        this.connectObservers = [];
        this.used = true;
        return new Promise((resolve, reject) => {
            this._addConnectObserver(resolve);
            let obj = {};
            obj['tcp' + this.id] = {
                connect: {
                    port: port,
                    domain: domain,
                },
            };
            this.Obniz.send(obj);
        });
    }
    close() {
        if (!this.used) {
            throw new Error(`tcp${this.id} is not used`);
        }
        let obj = {};
        obj['tcp' + this.id] = {
            disconnect: true,
        };
        this.Obniz.send(obj);
    }
    write(data) {
        if (!this.used) {
            throw new Error(`tcp${this.id} is not started`);
        }
        if (data === undefined) {
            return;
        }
        if (typeof data === 'number') {
            data = [data];
        }
        let send_data = null;
        if (isNode && data instanceof Buffer) {
            send_data = [...data];
        }
        else if (data.constructor === Array) {
            send_data = data;
        }
        else if (typeof data === 'string') {
            const buf = Buffer.from(data);
            send_data = [...buf];
        }
        let obj = {};
        obj['tcp' + this.id] = {
            write: {
                data: send_data,
            },
        };
        this.Obniz.send(obj);
    }
    readWait() {
        if (!this.used) {
            throw new Error(`tcp${this.id} is not started`);
        }
        return new Promise((resolve, reject) => {
            this._addReadObserver(resolve);
        });
    }
    end() {
        this.close();
    }
    notified(obj) {
        if (obj.connection) {
            /* Connectino state update. response of connect(), close from destination, response from */
            if (this.onconnection) {
                this.onconnection(obj.connection.connected);
            }
            if (!obj.connection.connected) {
                this._reset();
            }
        }
        else if (obj.read) {
            if (this.onreceive) {
                this.onreceive(obj.read.data);
            }
            let callback = this.readObservers.shift();
            if (callback) {
                callback(obj.read.data);
            }
        }
        else if (obj.connect) {
            /* response of connect() */
            /* `this.connection` will called before this function */
            if (obj.connect.code !== 0) {
                if (this.onerror) {
                    this.onerror(obj.connect);
                }
            }
            let callback = this.connectObservers.shift();
            if (callback) {
                callback(obj.connect.code);
            }
        }
    }
    isUsed() {
        return this.used;
    }
}
module.exports = Tcp;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9vYm5pei9saWJzL3Byb3RvY29sL3RjcC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxNQUFNLEdBQUcsT0FBTyxNQUFNLEtBQUssV0FBVyxDQUFDO0FBQzdDLE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUVqQyxNQUFNLEdBQUc7SUFDUCxZQUFZLEtBQUssRUFBRSxFQUFFO1FBQ25CLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDO1FBQ2IsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQ2hCLENBQUM7SUFFRCxNQUFNO1FBQ0osSUFBSSxDQUFDLGdCQUFnQixHQUFHLEVBQUUsQ0FBQztRQUMzQixJQUFJLENBQUMsYUFBYSxHQUFHLEVBQUUsQ0FBQztRQUN4QixJQUFJLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQztJQUNwQixDQUFDO0lBRUQsbUJBQW1CLENBQUMsUUFBUTtRQUMxQixJQUFJLFFBQVEsRUFBRTtZQUNaLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDdEM7SUFDSCxDQUFDO0lBRUQsZ0JBQWdCLENBQUMsUUFBUTtRQUN2QixJQUFJLFFBQVEsRUFBRTtZQUNaLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQ25DO0lBQ0gsQ0FBQztJQUVELFdBQVcsQ0FBQyxJQUFJLEVBQUUsTUFBTTtRQUN0QixJQUFJLE1BQU0sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLEVBQUUsT0FBTyxDQUFDLEVBQUU7WUFDL0MsTUFBTSxJQUFJLEtBQUssQ0FBQyx1Q0FBdUMsQ0FBQyxDQUFDO1NBQzFEO1FBRUQsT0FBTztRQUNQLG1CQUFtQjtRQUNuQixpREFBaUQ7UUFDakQsSUFBSTtRQUVKLElBQUksSUFBSSxHQUFH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SUFBSSxDQUFDLGdCQUFnQixDQUFDLEtBQUssRUFBRSxDQUFDO1lBQzdDLElBQUksUUFBUSxFQUFFO2dCQUNaLFFBQVEsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQzVCO1NBQ0Y7SUFDSCxDQUFDO0lBRUQsTUFBTTtRQUNKLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztJQUNuQixDQUFDO0NBQ0Y7QUFFRCxNQUFNLENBQUMsT0FBTyxHQUFHLEdBQUcsQ0FBQyIsImZpbGUiOiJvYm5pei9saWJzL3Byb3RvY29sL3RjcC5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGlzTm9kZSA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xuY29uc3Qgc2VtdmVyID0gcmVxdWlyZSgnc2VtdmVyJyk7XG5cbmNsYXNzIFRjcCB7XG4gIGNvbnN0cnVjdG9yKE9ibml6LCBpZCkge1xuICAgIHRoaXMuT2JuaXogPSBPYm5pejtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5fcmVzZXQoKTtcbiAgfVxuXG4gIF9yZXNldCgpIHtcbiAgICB0aGlzLmNvbm5lY3RPYnNlcnZlcnMgPSBbXTtcbiAgICB0aGlzLnJlYWRPYnNlcnZlcnMgPSBbXTtcbiAgICB0aGlzLnVzZWQgPSBmYWxzZTtcbiAgfVxuXG4gIF9hZGRDb25uZWN0T2JzZXJ2ZXIoY2FsbGJhY2spIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuY29ubmVjdE9ic2VydmVycy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cblxuICBfYWRkUmVhZE9ic2VydmVyKGNhbGxiYWNrKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnJlYWRPYnNlcnZlcnMucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdFdhaXQocG9ydCwgZG9tYWluKSB7XG4gICAgaWYgKHNlbXZlci5sdCh0aGlzLk9ibml6LmZpcm13YXJlX3ZlciwgJzIuMS4wJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUGxlYXNlIHVwZGF0ZSBvYm5peiBmaXJtd2FyZSA+PSAyLjEuMGApO1xuICAgIH1cblxuICAgIC8vIFRPRE9cbiAgICAvLyBpZiAodGhpcy51c2VkKSB7XG4gICAgLy8gICB0aHJvdyBuZXcgRXJyb3IoYHRjcCR7dGhpcy5pZH0gaXMgaW4gdXNlZGApO1xuICAgIC8vIH1cblxuICAgIGlmIChwb3J0IDwgMCB8fCBwb3J0ID4gNjU1MzUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdGNwJHt0aGlzLmlkfSBpcyBpbnZhbGlkIHBvcnRgKTtcbiAgICB9XG4gICAgaWYgKGRvbWFpbi5sZW5ndGggPiAzMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0Y3Ake3RoaXMuaWR9IGlzIGRvbWFpbiBsZW5ndGggb3ZlcmApO1xuICAgIH1cblxuICAgIHRoaXMuY29ubmVjdE9ic2VydmVycyA9IFtdO1xuICAgIHRoaXMudXNlZCA9IHRydWU7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX2FkZENvbm5lY3RPYnNlcnZlcihyZXNvbHZlKTtcbiAgICAgIGxldCBvYmogPSB7fTtcbiAgICAgIG9ialsndGNwJyArIHRoaXMuaWRdID0ge1xuICAgICAgICBjb25uZWN0OiB7XG4gICAgICAgICAgcG9ydDogcG9ydCxcbiAgICAgICAgICBkb21haW46IGRvbWFpbixcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgICB0aGlzLk9ibml6LnNlbmQob2JqKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIGlmICghdGhpcy51c2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHRjcCR7dGhpcy5pZH0gaXMgbm90IHVzZWRgKTtcbiAgICB9XG4gICAgbGV0IG9iaiA9IHt9O1xuICAgIG9ialsndGNwJyArIHRoaXMuaWRdID0ge1xuICAgICAgZGlzY29ubmVjdDogdHJ1ZSxcbiAgICB9O1xuICAgIHRoaXMuT2JuaXouc2VuZChvYmopO1xuICB9XG5cbiAgd3JpdGUoZGF0YSkge1xuICAgIGlmICghdGhpcy51c2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHRjcCR7dGhpcy5pZH0gaXMgbm90IHN0YXJ0ZWRgKTtcbiAgICB9XG4gICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSB7XG4gICAgICBkYXRhID0gW2RhdGFdO1xuICAgIH1cblxuICAgIGxldCBzZW5kX2RhdGEgPSBudWxsO1xuICAgIGlmIChpc05vZGUgJiYgZGF0YSBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgc2VuZF9kYXRhID0gWy4uLmRhdGFdO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgIHNlbmRfZGF0YSA9IGRhdGE7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgICAgc2VuZF9kYXRhID0gWy4uLmJ1Zl07XG4gICAgfVxuICAgIGxldCBvYmogPSB7fTtcbiAgICBvYmpbJ3RjcCcgKyB0aGlzLmlkXSA9IHtcbiAgICAgIHdyaXRlOiB7XG4gICAgICAgIGRhdGE6IHNlbmRfZGF0YSxcbiAgICAgIH0sXG4gICAgfTtcbiAgICB0aGlzLk9ibml6LnNlbmQob2JqKTtcbiAgfVxuXG4gIHJlYWRXYWl0KCkge1xuICAgIGlmICghdGhpcy51c2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHRjcCR7dGhpcy5pZH0gaXMgbm90IHN0YXJ0ZWRgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX2FkZFJlYWRPYnNlcnZlcihyZXNvbHZlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGVuZCgpIHtcbiAgICB0aGlzLmNsb3NlKCk7XG4gIH1cblxuICBub3RpZmllZChvYmopIHtcbiAgICBpZiAob2JqLmNvbm5lY3Rpb24pIHtcbiAgICAgIC8qIENvbm5lY3Rpbm8gc3RhdGUgdXBkYXRlLiByZXNwb25zZSBvZiBjb25uZWN0KCksIGNsb3NlIGZyb20gZGVzdGluYXRpb24sIHJlc3BvbnNlIGZyb20gKi9cbiAgICAgIGlmICh0aGlzLm9uY29ubmVjdGlvbikge1xuICAgICAgICB0aGlzLm9uY29ubmVjdGlvbihvYmouY29ubmVjdGlvbi5jb25uZWN0ZWQpO1xuICAgICAgfVxuICAgICAgaWYgKCFvYmouY29ubmVjdGlvbi5jb25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9iai5yZWFkKSB7XG4gICAgICBpZiAodGhpcy5vbnJlY2VpdmUpIHtcbiAgICAgICAgdGhpcy5vbnJlY2VpdmUob2JqLnJlYWQuZGF0YSk7XG4gICAgICB9XG4gICAgICBsZXQgY2FsbGJhY2sgPSB0aGlzLnJlYWRPYnNlcnZlcnMuc2hpZnQoKTtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhvYmoucmVhZC5kYXRhKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9iai5jb25uZWN0KSB7XG4gICAgICAvKiByZXNwb25zZSBvZiBjb25uZWN0KCkgKi9cbiAgICAgIC8qIGB0aGlzLmNvbm5lY3Rpb25gIHdpbGwgY2FsbGVkIGJlZm9yZSB0aGlzIGZ1bmN0aW9uICovXG4gICAgICBpZiAob2JqLmNvbm5lY3QuY29kZSAhPT0gMCkge1xuICAgICAgICBpZiAodGhpcy5vbmVycm9yKSB7XG4gICAgICAgICAgdGhpcy5vbmVycm9yKG9iai5jb25uZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGNhbGxiYWNrID0gdGhpcy5jb25uZWN0T2JzZXJ2ZXJzLnNoaWZ0KCk7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sob2JqLmNvbm5lY3QuY29kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaXNVc2VkKCkge1xuICAgIHJldHVybiB0aGlzLnVzZWQ7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUY3A7XG4iXX0=
