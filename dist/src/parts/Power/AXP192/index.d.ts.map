{"version":3,"sources":["../src/parts/Power/AXP192/index.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,MAAM,gBAAgB,CAAC;AACnC,OAAO,mBAAmB,EAAE,EAAC,cAAc,EAAC,MAAM,oCAAoC,CAAC;AAEvF,MAAM,WAAW,aAAa;CAAI;AAClC,cAAM,MAAO,YAAW,mBAAmB;WAE3B,IAAI,IAAI,cAAc;IAM7B,YAAY,EAAE,MAAM,EAAE,CAAC;IACvB,IAAI,EAAE,MAAM,EAAE,CAAC;IACf,MAAM,EAAE,GAAG,CAAC;IACZ,GAAG,EAAE,GAAG,CAAC;;IAOT,KAAK,CAAC,KAAK,EAAE,KAAK;IAOlB,GAAG,CAAC,OAAO,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG;IAIrB,OAAO,CAAC,OAAO,EAAE,GAAG;IAKpB,cAAc,CAAC,OAAO,EAAE,GAAG;IAiB3B,cAAc,CAAC,OAAO,EAAE,GAAG;IAgBjC,WAAW;IAIX,YAAY;IAIN,UAAU,CAAC,GAAG,EAAE,GAAG;IAOnB,UAAU,CAAC,GAAG,EAAE,GAAG;IAOzB,YAAY;IAcN,OAAO;CAOrB;AAED,eAAe,MAAM,CAAC","file":"index.d.ts","sourcesContent":["import Obniz from \"../../../obniz\";\nimport ObnizPartsInterface, {ObnizPartsInfo} from \"../../../obniz/ObnizPartsInterface\";\n\nexport interface AXP192Options { }\nclass AXP192 implements ObnizPartsInterface {\n\n  public static info(): ObnizPartsInfo {\n    return {\n      name: \"AXP192\",\n    };\n  }\n\n  public requiredKeys: string[];\n  public keys: string[];\n  public params: any;\n  public i2c: any;\n\n  constructor() {\n    this.requiredKeys = [];\n    this.keys = [\"sda\", \"scl\", \"i2c\"];\n  }\n\n  public wired(obniz: Obniz) {\n    this.params.mode = \"master\"; // for i2c\n    this.params.clock = 400 * 1000; // for i2c\n    this.i2c = obniz.getI2CWithConfig(this.params);\n  }\n\n  // Module functions\n  public set(address: any, data: any) {\n    this.i2c.write(AXP192_ADDRESS, [address, data]);\n  }\n\n  public async getWait(address: any) {\n    this.i2c.write(AXP192_ADDRESS, [address]);\n    return await this.i2c.readWait(AXP192_ADDRESS, 1);\n  }\n\n  public async setLDO2Voltage(voltage: any) {\n    if (voltage < 1.8) {\n      voltage = 1.8;\n    }\n    if (voltage > 3.3) {\n      voltage = 3.3;\n    }\n    let set: any = await this.getWait(REG_VOLT_SET_LDO2_3);\n    let offset: any = (voltage - 1.8) * 10;\n    if (offset > 15) {\n      offset = 15;\n    }\n    set = (set & 0x0f) | (offset << 4);\n    console.log(\"set voltage to \", set);\n    this.set(REG_VOLT_SET_LDO2_3, set);\n  }\n\n  public async setLDO3Voltage(voltage: any) {\n    if (voltage < 1.8) {\n      voltage = 1.8;\n    }\n    if (voltage > 3.3) {\n      voltage = 3.3;\n    }\n    let set: any = await this.getWait(REG_VOLT_SET_LDO2_3);\n    let offset: any = (voltage - 1.8) * 10;\n    if (offset > 15) {\n      offset = 15;\n    }\n    set = (set & 0xf0) | offset;\n    this.set(REG_VOLT_SET_LDO2_3, set);\n  }\n\n  public set3VLDO2_3() {\n    this.set(REG_VOLT_SET_LDO2_3, 0xcc);\n  }\n\n  public enableLDO2_3() {\n    this.set(REG_EN_DC1_LDO2_3, 0x4d);\n  }\n\n  public async toggleLDO2(val: any) {\n    const bit: any = val ? 1 : 0;\n    let state: any = await this.getWait(REG_EN_DC1_LDO2_3);\n    state = (state & LDO2_EN_MASK) | (bit << 2);\n    this.set(REG_EN_DC1_LDO2_3, state);\n  }\n\n  public async toggleLDO3(val: any) {\n    const bit: any = val ? 1 : 0;\n    let state: any = await this.getWait(REG_EN_DC1_LDO2_3);\n    state = (state & LDO3_EN_MASK) | (bit << 3);\n    this.set(REG_EN_DC1_LDO2_3, state);\n  }\n\n  public initM5StickC() {\n    this.i2c.write(AXP192_ADDRESS, [REG_EN_EXT_DC2, 0xff]);\n    this.i2c.write(AXP192_ADDRESS, [REG_VOLT_SET_LDO2_3, 0xcc]);\n    this.i2c.write(AXP192_ADDRESS, [REG_ADC_EN1, 0xff]);\n    this.i2c.write(AXP192_ADDRESS, [REG_CHARGE_CTRL1, 0xc0]);\n    this.i2c.write(AXP192_ADDRESS, [REG_CCOUNTER, 0x80]);\n    this.i2c.write(AXP192_ADDRESS, [REG_EN_DC1_LDO2_3, 0x4d]);\n    this.i2c.write(AXP192_ADDRESS, [REG_PEK, 0x0c]);\n    this.i2c.write(AXP192_ADDRESS, [REG_GPIO0, 0x02]);\n    this.i2c.write(AXP192_ADDRESS, [REG_VBUS_IPSOUT, 0xe0]);\n    this.i2c.write(AXP192_ADDRESS, [REG_CHARGE_OVTEMP, 0xfc]);\n    this.i2c.write(AXP192_ADDRESS, [REG_BCKUP_BAT, 0xa2]);\n  }\n\n  public async getVbat() {\n    this.i2c.write(AXP192_ADDRESS, [REG_VBAT_LSB]);\n    const vbat_lsb: any = await this.i2c.readWait(AXP192_ADDRESS, 1);\n    this.i2c.write(AXP192_ADDRESS, [REG_VBAT_MSB]);\n    const vbat_msb: any = await this.i2c.readWait(AXP192_ADDRESS, 1);\n    return (vbat_lsb << 4) + vbat_msb;\n  }\n}\n\nexport default AXP192;\n\nconst AXP192_ADDRESS: any = 0x34;\n\nconst REG_EN_EXT_DC2: any = 0x10;\nconst REG_EN_DC1_LDO2_3: any = 0x12;\nconst REG_VOLT_SET_LDO2_3: any = 0x28;\nconst REG_VBUS_IPSOUT: any = 0x30;\nconst REG_CHARGE_CTRL1: any = 0x33;\nconst REG_BCKUP_BAT: any = 0x35;\nconst REG_PEK: any = 0x36;\nconst REG_CHARGE_OVTEMP: any = 0x39;\nconst REG_VBAT_LSB: any = 0x78;\nconst REG_VBAT_MSB: any = 0x79;\nconst REG_ADC_EN1: any = 0x82;\nconst REG_GPIO0: any = 0x90;\nconst REG_CCOUNTER: any = 0xb8;\n\nconst LDO2_EN_MASK: any = 0xfb;\nconst LDO3_EN_MASK: any = 0xf7;\n"]}