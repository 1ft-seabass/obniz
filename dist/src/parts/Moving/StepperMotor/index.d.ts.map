{"version":3,"sources":["../src/parts/Moving/StepperMotor/index.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,MAAM,gBAAgB,CAAC;AACnC,OAAO,mBAAmB,EAAE,EAAC,cAAc,EAAC,MAAM,oCAAoC,CAAC;AAEvF,MAAM,WAAW,mBAAmB;CAAI;AACxC,cAAM,YAAa,YAAW,mBAAmB;WAEjC,IAAI,IAAI,cAAc;IAM7B,IAAI,EAAE,MAAM,EAAE,CAAC;IACf,YAAY,EAAE,MAAM,EAAE,CAAC;IACvB,iBAAiB,EAAE,GAAG,CAAC;IACvB,IAAI,EAAE,GAAG,CAAC;IACV,WAAW,EAAE,GAAG,CAAC;IACjB,SAAS,EAAE,GAAG,CAAC;IACf,SAAS,EAAE,GAAG,CAAC;IACf,iBAAiB,EAAE,GAAG,CAAC;IACvB,mBAAmB,EAAE,GAAG,CAAC;IACzB,KAAK,EAAG,KAAK,CAAC;IACd,MAAM,EAAE,GAAG,CAAC;IACZ,MAAM,EAAE,GAAG,CAAC;IACZ,GAAG,EAAE,GAAG,CAAC;;IA8BT,KAAK,CAAC,KAAK,EAAE,KAAK;IAiBZ,QAAQ,CAAC,UAAU,EAAE,GAAG;IAwDxB,UAAU,CAAC,WAAW,EAAE,GAAG;IAK3B,QAAQ;IAeR,QAAQ;IAOd,QAAQ,CAAC,QAAQ,EAAE,GAAG;IAQtB,KAAK,CAAC,YAAY,EAAE,GAAG;IAIvB,eAAe;IAKf,YAAY;IASN,UAAU,CAAC,QAAQ,EAAE,GAAG;IAMxB,YAAY,CAAC,KAAK,EAAE,GAAG;IAS7B,eAAe;IAKT,QAAQ,CAAC,QAAQ,EAAE,GAAG;IAKtB,UAAU,CAAC,WAAW,EAAE,GAAG;IAMjC,oBAAoB;CAG5B;AAED,eAAe,YAAY,CAAC","file":"index.d.ts","sourcesContent":["import Obniz from \"../../../obniz\";\nimport ObnizPartsInterface, {ObnizPartsInfo} from \"../../../obniz/ObnizPartsInterface\";\n\nexport interface StepperMotorOptions { }\nclass StepperMotor implements ObnizPartsInterface {\n\n  public static info(): ObnizPartsInfo {\n    return {\n      name: \"StepperMotor\",\n    };\n  }\n\n  public keys: string[];\n  public requiredKeys: string[];\n  public _stepInstructions: any;\n  public type: any;\n  public currentStep: any;\n  public _stepType: any;\n  public frequency: any;\n  public rotationStepCount: any;\n  public milliMeterStepCount: any;\n  public obniz!: Obniz;\n  public params: any;\n  public common: any;\n  public ios: any;\n\n  constructor() {\n    this.keys = [\"a\", \"b\", \"aa\", \"bb\", \"common\"];\n    this.requiredKeys = [\"a\", \"b\", \"aa\", \"bb\"];\n\n    this._stepInstructions = {\n      \"1\": [[0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0]],\n      \"2\": [[0, 0, 1, 1], [1, 0, 0, 1], [1, 1, 0, 0], [0, 1, 1, 0]],\n      \"1-2\": [\n        [0, 1, 1, 1],\n        [0, 0, 1, 1],\n        [1, 0, 1, 1],\n        [1, 0, 0, 1],\n        [1, 1, 0, 1],\n        [1, 1, 0, 0],\n        [1, 1, 1, 0],\n        [0, 1, 1, 0],\n      ],\n    };\n\n    this.type = undefined; // common exist? => unipolar : bipolar\n    this.currentStep = 0;\n    this._stepType = \"2\";\n    this.frequency = 100;\n\n    this.rotationStepCount = 100;\n    this.milliMeterStepCount = 1;\n  }\n\n  public wired(obniz: Obniz) {\n    this.obniz = obniz;\n\n    if (obniz.isValidIO(this.params.common)) {\n      this.common = obniz.getIO(this.params.common);\n      this.common.output(true);\n      this.type = \"unipolar\";\n    } else {\n      this.type = \"bipolar\";\n    }\n    this.ios = [];\n    this.ios.push(obniz.getIO(this.params.a));\n    this.ios.push(obniz.getIO(this.params.b));\n    this.ios.push(obniz.getIO(this.params.aa));\n    this.ios.push(obniz.getIO(this.params.bb));\n  }\n\n  public async stepWait(step_count: any) {\n    if (typeof step_count !== \"number\") {\n      throw new Error(\"must provide number\");\n    }\n    step_count = Math.round(step_count);\n    if (step_count === 0) {\n      return;\n    }\n    const step_count_abs: any = Math.abs(step_count);\n    const instructions: any = this._getStepInstructions();\n    const instruction_length: any = instructions.length;\n    const array: any = [];\n    // set instructions\n    let currentPhase: any = this.currentStep % instruction_length;\n    if (currentPhase < 0) {\n      currentPhase = instruction_length - currentPhase * -1;\n    }\n    if (step_count > 0) {\n      for (let i = 0; i < instructions.length; i++) {\n        if (++currentPhase >= instruction_length) {\n          currentPhase = 0;\n        }\n        array.push(instructions[currentPhase]);\n      }\n    } else {\n      for (let i = 0; i < instructions.length; i++) {\n        if (--currentPhase < 0) {\n          currentPhase = instruction_length - 1;\n        }\n        array.push(instructions[currentPhase]);\n      }\n    }\n    // prepare animation\n    let msec: any = 1000 / this.frequency;\n    msec = parseInt(msec);\n    if (msec < 1) {\n      msec = 1;\n    }\n    const state: any = (index: any) => {\n      const instruction: any = array[index];\n      for (let i = 0; i < this.ios.length; i++) {\n        this.ios[i].output(instruction[i]);\n      }\n    };\n    const states: any = [];\n    for (let i = 0; i < instruction_length; i++) {\n      states.push({\n        duration: msec,\n        state,\n      });\n    }\n    // execute and wait\n    await this.obniz.io!.repeatWait(states, step_count_abs);\n    this.currentStep += step_count;\n  }\n\n  public async stepToWait(destination: any) {\n    const mustmove: any = destination - this.currentStep;\n    await this.stepWait(mustmove);\n  }\n\n  public async holdWait() {\n    const instructions: any = this._getStepInstructions();\n    const instruction_length: any = instructions.length;\n    // set instructions\n    let currentPhase: any = this.currentStep % instruction_length;\n    if (currentPhase < 0) {\n      currentPhase = instruction_length - currentPhase * -1;\n    }\n\n    for (let i = 0; i < this.ios.length; i++) {\n      this.ios[i].output(instructions[currentPhase][i]);\n    }\n    await this.obniz.pingWait();\n  }\n\n  public async freeWait() {\n    for (let i = 0; i < this.ios.length; i++) {\n      this.ios[i].output(true);\n    }\n    await this.obniz.pingWait();\n  }\n\n  public stepType(stepType: any) {\n    const newType: any = this._stepInstructions[stepType];\n    if (!newType) {\n      throw new Error(\"unknown step type \" + stepType);\n    }\n    this._stepType = stepType;\n  }\n\n  public speed(step_per_sec: any) {\n    this.frequency = step_per_sec;\n  }\n\n  public currentRotation() {\n    // => degree\n    return (this.currentStep / this.rotationStepCount) * 360;\n  }\n\n  public currentAngle() {\n    // => degree\n    let angle: any = (Math.floor(this.currentRotation() * 1000) % 360000) / 1000;\n    if (angle < 0) {\n      angle = 360 - angle;\n    }\n    return angle;\n  }\n\n  public async rotateWait(rotation: any) {\n    rotation /= 360;\n    const needed: any = rotation * this.rotationStepCount;\n    await this.stepWait(needed);\n  }\n\n  public async rotateToWait(angle: any) {\n    let needed: any = angle - this.currentAngle();\n    if (Math.abs(needed) > 180) {\n      needed = needed > 0 ? needed - 360 : 360 + needed;\n    }\n    needed = (needed / 360) * this.rotationStepCount;\n    await this.stepWait(needed);\n  }\n\n  public currentDistance() {\n    // => mm\n    return this.currentStep / this.milliMeterStepCount;\n  }\n\n  public async moveWait(distance: any) {\n    const needed: any = distance * this.milliMeterStepCount;\n    await this.stepWait(needed);\n  }\n\n  public async moveToWait(destination: any) {\n    const needed: any =\n      (destination - this.currentDistance()) * this.milliMeterStepCount;\n    await this.stepWait(needed);\n  }\n\n  public _getStepInstructions() {\n    return this._stepInstructions[this._stepType];\n  }\n}\n\nexport default StepperMotor;\n"]}